--!strict
-- this script was generated by nightcycle/datatree, do not manually edit

--Services
local Players = game:GetService("Players")
local DataStoreService = require(script:WaitForChild("Packages"):WaitForChild("MockDataStoreService"))
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

--Packages
local NetworkUtil = require(script:WaitForChild("Packages"):WaitForChild("NetworkUtil"))
local Maid = require(script:WaitForChild("Packages"):WaitForChild("Maid"))
local Signal = require(script:WaitForChild("Packages"):WaitForChild("Signal"))
local Base64 = require(script:WaitForChild("Packages"):WaitForChild("Base64"))

--Modules
local DataTypes = require(game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("DataTreeTypes"))

--Types
type Table = {[any]: any}
type Signal = Signal.Signal
type Maid = Maid.Maid
export type VehicleType = DataTypes.VehicleType
export type PermissionData = DataTypes.PermissionData
export type PerformanceData = DataTypes.PerformanceData
export type VehicleData = DataTypes.VehicleData
export type UserId = number
export type UserIdKey = string
type Processor<V> = (val: V) -> V
type Serializer<D,S> = (data: D) -> S
type Deserializer<S,D> = (data: S) -> D
export type DataHandler<T, S> = {
	__index: DataHandler<T, S>,
	_Maid: Maid,
	_IsAlive: boolean,
	_Value: T?,
	_EncodedValue: S?,
	_Serialize: Serializer<T, S>,
	_Deserialize: Deserializer<S, T>,
	OnChanged: Signal,
	ClassName: "DataHandler",
	Key: UserIdKey,
	Player: Player,
	DataStore: DataStore,
	SetOptions: DataStoreSetOptions,
	IncrementOptions: DataStoreIncrementOptions,
	init: (maid: Maid) -> nil,
	new: (player: Player, scope: string, initialValue: T, _serializer: Serializer<T,S>?, _deserializer: Deserializer<S,T>?) -> DataHandler<T, S>,
	Destroy: (self: DataHandler<T, S>) -> nil,
	Get: (self: DataHandler<T, S>, force: boolean?) -> (T?, boolean),
	Set: (self: DataHandler<T, S>, data: T, force: boolean?) -> boolean,
	Update: (self: DataHandler<T, S>, transformer: (T) -> T, force: boolean?) -> (T?, boolean),
	Remove: (self: DataHandler<T, S>) -> nil,
}
export type SortedDataEntry = {
	UserId: number,
	Value: number,
}
export type NumberDataHandler = DataHandler<number, number> & {
	ClassName: "NumberDataHandler",
	DataStore: OrderedDataStore,
	_EncodedValue: number?,
	_Serialize: Processor<number>,
	_Deserialize: Processor<number>,
	_Value: number?,
	Increment: (self: NumberDataHandler, delta: number, force: boolean?) -> (number?, boolean),
	new: (player: Player, scope: string, initialValue: number, _processor: Processor<number>?) -> NumberDataHandler,
	GetSortedList: (self: NumberDataHandler, limit: number, isAscending: boolean) -> { [number]: SortedDataEntry },
}
export type DataTree = {
	CompanyName: DataHandler<string, string>,
	State: DataHandler<Enum.HumanoidStateType, string>,
	Location: DataHandler<CFrame, string>,
	Currency: {
		Cash: NumberDataHandler,
		VehicleCredits: NumberDataHandler,
	},
	Garage: {
		Slots: DataHandler<{[number]: VehicleData}, string>,
		Permissions: DataHandler<{[number]:  PermissionData?}, string>,
	},
}

--Constants
local BASE_DOMAIN = "gamework"
local GET_SUFFIX = "DATA_TREE_CLT_GET"
local UPDATE_SUFFIX = "DATA_TREE_CLT_UPDATE"
local PAGE_LENGTH = 100
local RETRY_LIMIT = 10
local RETRY_DELAY = 0.5
local METADATA = {
	["saved_at::DateTime"] = "NOW",
	["major"] = 1,
	["minor"] = 2,
	["patch"] = 3,
}

-- Private functions
function _serializeList(unitMethod: (((val: any) -> Table) | ((val: any) -> string) | ((val: number) -> number) | ((val: boolean) -> boolean))): (val: { [number]: any }) -> Table
	return function(listVal: { [number]: any }): Table
		local out = {}
		for i, v in ipairs(listVal) do
			out[i] = (unitMethod :: any)(v)
		end
		return out
	end
end
function _deserializeList(unitMethod: (((val: string) -> any) | ((val: Table) -> any) | ((val: number) -> number) | ((val: boolean) -> boolean))): (input: {[number]: any}) -> { [number]: any }
	return function(input: Table)
		local out = {}
		for i, v in ipairs(input) do
			out[i] = (unitMethod :: any)(v)
		end
		return out
	end
end
function _serializeDict(unitMethod: (((val: any) -> Table) | ((val: any) -> string) | ((val: number) -> number) | ((val: boolean) -> boolean))): (val: { [any]: any }) -> Table
	return function(dictVal: { [any]: any }): Table
		local out = {}
		for k, v in pairs(dictVal) do
			out[k] = (unitMethod :: any)(v)
		end
		return out
	end
end
function _deserializeDict(unitMethod: (((val: string) -> any) | ((val: Table) -> any) | ((val: number) -> number) | ((val: boolean) -> boolean))): (val: Table) -> { [any]: any }
	return function(input: Table): { [any]: any }
		local out = {}
		for k, v in pairs(input) do
			out[k] = (unitMethod :: any)(v)
		end
		return out
	end
end

local _processInteger = function(value: number): number
	return math.round(value)
end
local _processInt = _processInteger
local _processDouble = function(value: number): number
	return math.round(value*100)/100
end
local _processFloat = function(value: number): number
	return value
end



local _serializeColor3 = function(value: Color3): string
	return value:ToHex()
end
local _serializeNumber = function(value: number): number
	return value
end
local _serializeInteger = function(value: number): number
	return _processInteger(value)
end
local _serializeInt = _serializeInteger
local _serializeDouble = function(value: number): number
	return _processDouble(value)
end
local _serializeFloat = _serializeNumber
local _serializeString = function(value: string): string
	return value
end
local _serializeBoolean = function(value: boolean): boolean
	return value
end
local _serializeDateTime = function(value: DateTime): string
	return value:ToIsoDate()
end
local _serializeVector3 = function(value: Vector3): Table
	return {
		X = value.X,
		Y = value.Y,
		Z = value.Z
	}
end
local _serializeVector3Integer = function(value: Vector3): Table
	return {
		X = math.round(value.X),
		Y = math.round(value.Y),
		Z = math.round(value.Z)
	}
end
local _serializeVector3Double = function(value: Vector3): Table
	return {
		X = math.round(value.X*100)/100,
		Y = math.round(value.Y*100)/100,
		Z = math.round(value.Z*100)/100
	}
end
local _serializeVector2 = function(value: Vector2): Table
	return {
		X = value.X,
		Y = value.Y
	}
end
local _serializeVector2Integer = function(value: Vector2): Table
	return {
		X = math.round(value.X),
		Y = math.round(value.Y)
	}
end
local _serializeVector2Double = function(value: Vector2): Table
	return {
		X = math.round(value.X*100)/100,
		Y = math.round(value.Y*100)/100
	}
end
local _serializeCFrame = function(value: CFrame): Table
	local x,y,z = value:ToEulerAnglesYXZ()
	return {
		Position = _serializeVector3(value.Position),
		Orientation = _serializeVector3(Vector3.new(math.deg(x), math.deg(y), math.deg(z))),
	}
end
local _serializeCFrameDouble = function(value: CFrame): Table
	local x,y,z = value:ToEulerAnglesYXZ()
	return {
		Position = _serializeVector3Double(value.Position),
		Orientation = _serializeVector3Double(Vector3.new(math.deg(x), math.deg(y), math.deg(z))),
	}
end
local _serializeCFrameInteger = function(value: CFrame): Table
	local x,y,z = value:ToEulerAnglesYXZ()
	return {
		Position = _serializeVector3Integer(value.Position),
		Orientation = _serializeVector3Integer(Vector3.new(math.deg(x), math.deg(y), math.deg(z))),
	}
end
local _serializeEnum = function(value: EnumItem): string
	return tostring(value.Value)
end
local _serializeEnumMaterial = _serializeEnum :: (value: Enum.Material) -> string
local _serializeEnumHumanoidStateType = _serializeEnum :: (value: Enum.HumanoidStateType) -> string
local _serializeVehicleType = function(value: VehicleType): string
	local index = table.find({"Sedan","Hatchback","Truck",}, value)
	assert(index)
	return tostring(index)
end
local _serializePermissionData = function(value: PermissionData): Table
	return {
		["CanDrive"] = _serializeBoolean(value["CanDrive"]),
		["CanEdit"] = _serializeBoolean(value["CanEdit"]),
		["CanSell"] = _serializeBoolean(value["CanSell"]),
	}
end
local _serializePerformanceData = function(value: PerformanceData): Table
	return {
		["Speed"] = _serializeDouble(value["Speed"]),
		["Acceleration"] = _serializeDouble(value["Acceleration"]),
		["TurnSpeed"] = _serializeDouble(value["TurnSpeed"]),
	}
end
local _serializeVehicleData = function(value: VehicleData): Table
	return {
		["Name"] = _serializeString(value["Name"]),
		["Type"] = _serializeVehicleType(value["Type"]),
		["Id"] = _serializeString(value["Id"]),
		["PurchaseTime"] = _serializeDateTime(value["PurchaseTime"]),
		["FrictionCoefficient"] = _serializeDouble(value["FrictionCoefficient"]),
		["Material"] = _serializeEnumMaterial(value["Material"]),
		["Performance"] = _serializePerformanceData(value["Performance"]),
		["Appearance"] = {
			["Color"] = _serializeColor3(value["Appearance"]["Color"]),
			["Skin"] = if value["Appearance"]["Skin"] ~= nil then _serializeString(value["Appearance"]["Skin"]) else nil,
		},
	}
end



local _deserializeString = function(value: string): string
	return value
end
local _deserializeNumber = function(value: number): number
	return value
end
local _deserializeInteger = _deserializeNumber
local _deserializeInt = _deserializeInteger
local _deserializeDouble = _deserializeNumber
local _deserializeFloat = _deserializeNumber
local _deserializeBoolean = function(value: boolean): boolean
	return value
end
local _deserializeColor3 = function(value: string): Color3
	return Color3.fromHex(value)
end
local _deserializeDateTime = function(value: string): DateTime
	return DateTime.fromIsoDate(value)
end
local _deserializeVector3 = function(value: Table): Vector3
	return Vector3.new(value.X, value.Y, value.Z)
end
local _deserializeVector3Integer = function(value: Table): Vector3
	return Vector3.new(math.round(value.X), math.round(value.Y), math.round(value.Z))
end
local _deserializeVector3Double = function(value: Table): Vector3
	return Vector3.new(math.round(value.X*100)/100, math.round(value.Y*100)/100, math.round(value.Z*100)/100)
end
local _deserializeVector2 = function(value: Table): Vector2
	return Vector2.new(value.X, value.Y)
end
local _deserializeVector2Integer = function(value: Table): Vector2
	return Vector2.new(math.round(value.X), math.round(value.Y))
end
local _deserializeVector2Double = function(value: Table): Vector2
	return Vector2.new(math.round(value.X*100)/100, math.round(value.Y*100)/100)
end
local _deserializeCFrame = function(value: Table): CFrame
	local position = _deserializeVector3(value["Position"])
	local orientation = _deserializeVector3(value["Orientation"])
	return CFrame.fromEulerAnglesYXZ(
		math.rad(orientation.X),
		math.rad(orientation.Y),
		math.rad(orientation.Z)
	) + position
end
local _deserializeCFrameInteger = function(value: Table): CFrame
	local position = _deserializeVector3Integer(value["Position"])
	local orientation = _deserializeVector3Integer(value["Orientation"])
	return CFrame.fromEulerAnglesYXZ(
		math.rad(orientation.X),
		math.rad(orientation.Y),
		math.rad(orientation.Z)
	) + position
end
local _deserializeCFrameDouble = function(value: Table): CFrame
	local position = _deserializeVector3Double(value["Position"])
	local orientation = _deserializeVector3Double(value["Orientation"])
	return CFrame.fromEulerAnglesYXZ(
		math.rad(orientation.X),
		math.rad(orientation.Y),
		math.rad(orientation.Z)
	) + position
end
local _deserializeEnumHumanoidStateType = function(value: string): Enum.HumanoidStateType
	for i, enumItem in ipairs(Enum.HumanoidStateType:GetEnumItems()) do if enumItem.Value == tonumber(value) then return enumItem end end
	error("No enum item found in HumanoidStateType for value "..value)
end
local _deserializeEnumMaterial = function(value: string): Enum.Material
	for i, enumItem in ipairs(Enum.Material:GetEnumItems()) do if enumItem.Value == tonumber(value) then return enumItem end end
	error("No enum item found in Material for value "..value)
end
local _deserializeVehicleType = function(value: number): VehicleType
	local options = {"Sedan","Hatchback","Truck",}
	local index = tonumber(value)
	assert(index)
	return options[index] :: VehicleType
end
local _deserializePermissionData = function(data: Table): PermissionData
	return {
		["CanDrive"] = _deserializeBoolean(data["CanDrive"]),
		["CanEdit"] = _deserializeBoolean(data["CanEdit"]),
		["CanSell"] = _deserializeBoolean(data["CanSell"]),
	} :: any
end
local _deserializePerformanceData = function(data: Table): PerformanceData
	return {
		["Speed"] = _deserializeNumber(data["Speed"]),
		["Acceleration"] = _deserializeNumber(data["Acceleration"]),
		["TurnSpeed"] = _deserializeNumber(data["TurnSpeed"]),
	} :: any
end
local _deserializeVehicleData = function(data: Table): VehicleData
	return {
		["Name"] = _deserializeString(data["Name"]),
		["Type"] = _deserializeVehicleType(data["Type"]),
		["Id"] = _deserializeString(data["Id"]),
		["PurchaseTime"] = _deserializeDateTime(data["PurchaseTime"]),
		["FrictionCoefficient"] = _deserializeNumber(data["FrictionCoefficient"]),
		["Material"] = _deserializeEnumMaterial(data["Material"]),
		["Performance"] = _deserializePerformanceData(data["Performance"]),
		["Appearance"] = {
			["Color"] = _deserializeColor3(data["Appearance"]["Color"]),
			["Skin"] = if data["Appearance"]["Skin"] ~= nil then _deserializeString(data["Appearance"]["Skin"]) else nil,
		},
	} :: any
end

--Class
local DataHandler: DataHandler<any, string> = {} :: any
DataHandler.__index = DataHandler

function DataHandler:Destroy()
	if not self._IsAlive then
		return
	end
	
	self._IsAlive = false
	self:Set(self._Value, true)
	self._Maid:Destroy()
	local t: any = self
	for k, v in pairs(t) do
		t[k] = nil
	end
	setmetatable(t, nil)
	return nil
end
function DataHandler:Set(data: any, force: boolean?)
	local initialValue = self._EncodedValue
	local function set()
		local success, errorMessage = pcall(function()
			self.DataStore:SetAsync(self.Key, self._Serialize(data), { self.Player.UserId }, self.SetOptions)
		end)
		if not success then
			warn(errorMessage)
		end
		return success
	end
	local success
	if force then
		local attempts = 0
		repeat
			attempts += 1
			success = set()
			if not success then
				task.wait(RETRY_DELAY)
			end
		until success or attempts > RETRY_LIMIT
	else
		success = true
	end
		if data then
			if type(data) == "string" then
				self._EncodedValue = self._Serialize(data) -- Base64.Encode(self._Serialize(data))
			else
				self._EncodedValue = self._Serialize(data)
			end
		else
			self._EncodedValue = nil
		end
		if self._EncodedValue then
			if type(self._EncodedValue) == "string" then
				self._Value = self._Deserialize(self._EncodedValue) -- self._Deserialize(Base64.Decode(self._EncodedValue))
			else
					self._Value = self._Deserialize(self._EncodedValue)
			end
		else
			self._Value = nil
		end
	if initialValue ~= data then
		self.OnChanged:Fire(self._Value)
	end
	return success
end
function DataHandler:Update(transformer: (any) -> any, force: boolean?)
	local initialValue = self._EncodedValue
	local function transformerWrapper(rawValue: any)
		 return self._Serialize(transformer(self._Deserialize(rawValue)))
	end
	local function update()
		local value = self._EncodedValue
		local success, msg = pcall(function()
			value = self.DataStore:UpdateAsync(self.Key, transformerWrapper)
		end)
		if not success then
			warn(msg)
		end
		return value, success
	end
	
	local value, success
	if force then
		local attempts = 0
		repeat
			attempts += 1
			value, success = update()
			if not success then
				task.wait(RETRY_DELAY)
			end
		until success or attempts > RETRY_LIMIT
		if success then
			self._EncodedValue = value
		end
	else
		value = transformerWrapper(initialValue)
		if value then
			if type(value) == "string" then
				self._EncodedValue = self._Serialize(value) -- Base64.Encode(self._Serialize(value))
			else
				self._EncodedValue = self._Serialize(value)
			end
		else
			self._EncodedValue = nil
		end
	end
		if self._EncodedValue then
			if type(self._EncodedValue) == "string" then
				self._Value = self._Deserialize(self._EncodedValue) -- self._Deserialize(Base64.Decode(self._EncodedValue))
			else
					self._Value = self._Deserialize(self._EncodedValue)
			end
		else
			self._Value = nil
		end
	if initialValue ~= value then
		self.OnChanged:Fire(self._Value)
	end
	return self._Value, success
end

function DataHandler:Get(force: boolean?): (any?, boolean)
	if self._Value ~= nil and not force then
		return self._Value, true
	end
	
	local function get()
		local data
		local success, msg = pcall(function()
			data = self.DataStore:GetAsync(self.Key)
		end)
		if not success then
			warn(msg)
		end
		return data, success
	end
	
	local data, success
	local attempts = 0
	repeat
		attempts += 1
		data, success = get()
		if not success then
			task.wait(RETRY_DELAY)
		end
	until success or attempts > RETRY_LIMIT
	
	if success then
		self._EncodedValue = data
		if self._EncodedValue then
			if type(self._EncodedValue) == "string" then
				self._Value = self._Deserialize(self._EncodedValue) -- self._Deserialize(Base64.Decode(self._EncodedValue))
			else
					self._Value = self._Deserialize(self._EncodedValue)
			end
		else
			self._Value = nil
		end
	end
	
	return self._Value, success
end

function DataHandler.new(player: Player, scope: string, initialValue: any, _serializer: Serializer<any, any>?, _deserializer: Deserializer<any, any>?)
	local maid = Maid.new()
	
	local dataStoreOptions = Instance.new("DataStoreOptions")
	maid:GiveTask(dataStoreOptions)
	
	local setOptions = Instance.new("DataStoreSetOptions")
	maid:GiveTask(setOptions)
	setOptions:SetMetadata(METADATA)
	
	local onChanged = Signal.new()
	maid:GiveTask(onChanged)
	
	local self: DataHandler<any, string> = setmetatable({
		_Maid = maid,
		_IsAlive = true,
		_Serialize = if _serializer then
			function(v: any)
				return if type(v) == "table" then Base64.Encode(HttpService:JSONEncode(_serializer(v))) else v
			end
		else function(v: any) return v end,
		_Deserialize = if _deserializer then 
			function(v: any)
				local out: any
				local success, _msg = pcall(function()
					out = _deserializer(HttpService:JSONDecode(Base64.Decode(v)))
				end)
				return if success then out else v	end
		else function(v: any) return v end,
		OnChanged = onChanged,
		DataStore =  DataStoreService:GetDataStore(BASE_DOMAIN, scope, dataStoreOptions),
		_Value = initialValue,
		Key = tostring(player.UserId),
		SetOptions = setOptions,
		Player = player,
	}, DataHandler) :: any
	
	if RunService:IsRunning() then
		local updateEvent = NetworkUtil.getRemoteEvent(scope .. "_" .. UPDATE_SUFFIX, player)
		maid:GiveTask(updateEvent)
		
		maid:GiveTask(onChanged:Connect(function(v: any)
			updateEvent:FireClient(player, v)
		end))
		
		local getFunction = NetworkUtil.getRemoteFunction(scope .. "_" .. GET_SUFFIX, player)
		maid:GiveTask(getFunction)
		getFunction.OnServerInvoke = function(plr: Player)
			if player.UserId == plr.UserId then
				return self._Value
			end
			error("Bad player")
		end
	else
		local updateEvent = NetworkUtil.getBindableEvent(scope .. "_" .. UPDATE_SUFFIX)
		maid:GiveTask(updateEvent)
		
		maid:GiveTask(onChanged:Connect(function(v: any)
			updateEvent:Fire(v)
		end))
		
		local getFunction = NetworkUtil.getBindableFunction(scope .. "_" .. GET_SUFFIX)
		maid:GiveTask(getFunction)
		getFunction.OnInvoke = function()
			return self._Value
		end
	end
	
	self._Value = self:Get(true)
	if self._Value == nil then self._Value = initialValue end
	return self
end

local NumberDataHandler = {}
NumberDataHandler.__index = NumberDataHandler
setmetatable(NumberDataHandler, DataHandler)

-- @TODO
function NumberDataHandler:GetSortedList(player: Player, limit: number, isAscending: boolean)
	local pages = self.Datastore:GetSortedAsync(isAscending, PAGE_LENGTH)
	
	local list: { [number]: SortedDataEntry } = {}
	local function dumpPages()
		local page = pages:GetCurrentPage()
		
		for rank: number, data in ipairs(page) do
			if #list >= limit then
				break
			end
			local key = data.key
			local value = data.value
			table.insert(list, {
				UserId = tonumber(key) :: number,
				Value = value,
			})
		end
		
		local success
		local attempts = 0
		repeat
			success = pcall(function() end)
			attempts += 1
			if not success then
				task.wait(RETRY_DELAY)
			end
		until success or attempts > RETRY_LIMIT
		
		if success and #list < limit then
			pages:AdvanceToNextPageAsync()
			dumpPages()
		end
	end
	dumpPages()
	
	return list
end

function NumberDataHandler:Increment(delta: number, force: boolean?)
	local function increment()
		local value = self._EncodedValue
		local success, msg = pcall(function()
			local val = self.DataStore:IncrementAsync(self.Key, delta, { self.Player.UserId }, self.IncrementOptions)
			value = val
			return val
		end)
		if not success then
			warn(msg)
		end
		return value, success
	end
	
	local value, success
	
	if force then
		local attempts = 0
		repeat
			attempts += 1
			value, success = increment()
			if not success then
				task.wait(RETRY_DELAY)
			end
		until success or attempts > RETRY_LIMIT
		if success then
			self._EncodedValue = value
			self._Value = self.Deserialize(self._EncodedValue)end
	else
		local val: number = self._EncodedValue
		val += delta
		self._EncodedValue = val
		self._Value = self.Deserialize(self._EncodedValue)
		success = true
	end
	
	if success and delta ~= 0 then
		self.OnChanged:Fire(self._Value)
	end
	
	return self._Value, success
end

function NumberDataHandler.new(player: Player, scope: string, initialValue: number, _processor: Processor<number>?): NumberDataHandler
	local self: NumberDataHandler = setmetatable(DataHandler.new(player, scope, initialValue, _processor :: any, _processor :: any), NumberDataHandler) :: any
	
	self.DataStore = DataStoreService:GetOrderedDataStore(BASE_DOMAIN, scope)
	
	local incrementOptions = Instance.new("DataStoreIncrementOptions")
	self._Maid:GiveTask(incrementOptions)
	
	incrementOptions:SetMetadata(METADATA)
	self.IncrementOptions = incrementOptions
	
	return self
end
local trees: { [number]: any } = {}

function initPlayer(playerMaid: Maid, player: Player)
	local function _newDataHandler<G, S>(path: string, val: any, _serializer: Serializer<G,S>?, _deserializer: Deserializer<S, G>?): DataHandler<G, S>
		local handler: DataHandler<G,S> = DataHandler.new(player, path, val, _serializer :: any, _deserializer :: any) :: any
		playerMaid:GiveTask(handler)
		
		return handler
	end
	
	local function _newNumberHandler(path: string, val: number, _processor: Processor<number>?): NumberDataHandler
		local handler: NumberDataHandler = NumberDataHandler.new(player, path, val, _processor) :: any
		playerMaid:GiveTask(handler)
		
		return handler
	end
	
	local treeStateVal: Enum.HumanoidStateType = Enum.HumanoidStateType.Dead
	local treeGarageSlotsVal: {[number]:VehicleData} = {
{
	["Name"] = "Lightning McCar",
	["Type"] = "Sedan",
	["Id"] = ""..game:GetService("HttpService"):GenerateGUID(false).."",
	["FrictionCoefficient"] = math.round(100*0.5)/100,
	["Performance"] = {
	["Speed"] = math.round(100*12.0)/100,
	["Acceleration"] = math.round(100*25.0)/100,
	["TurnSpeed"] = math.round(100*5.0)/100,
} :: PerformanceData,
	["Appearance"] = {
		["Color"] = Color3.fromRGB(256, 128, 64),
		["Skin"] = "Lightning",
	},
} :: VehicleData,
}
	local treeGaragePermissionsVal: {[number]: PermissionData?} = {
	[12345] = {
	["CanDrive"] = false,
	["CanEdit"] = true,
	["CanSell"] = true,
} :: PermissionData,
}
	local tree: DataTree = {
			["CompanyName"] = _newDataHandler("CompanyName", ""..player.DisplayName.."'s Company"),
			["State"] = _newDataHandler("State", treeStateVal, _serializeEnumHumanoidStateType, _deserializeEnumHumanoidStateType),
			["Location"] = _newDataHandler("Location"),
			["Currency"] = {
				["Cash"] = _newNumberHandler("Currency/Cash", 1000, _processInt),
				["VehicleCredits"] = _newNumberHandler("Currency/VehicleCredits", 5, _processInt),
			},
			["Garage"] = {
				["Slots"] = _newDataHandler("Garage/Slots", treeGarageSlotsVal, _serializeList(_serializeVehicleData), _deserializeList(_deserializeVehicleData)) :: any,
				["Permissions"] = _newDataHandler("Garage/Permissions", treeGaragePermissionsVal, _serializeDict(_serializePermissionData), _deserializeDict(_deserializePermissionData)) :: any,
			},
		}
	trees[player.UserId] = tree
end

return {
	init = function(maid: Maid): nil
		local function onPlayerAdded(player: Player)
			local playerMaid = Maid.new()
			maid:GiveTask(playerMaid)
			initPlayer(playerMaid, player)
			playerMaid:GiveTask(player.Destroying:Connect(function()
				trees[player.UserId] = nil
				playerMaid:Destroy()
			end))
		end
		
		maid:GiveTask(Players.PlayerAdded:Connect(onPlayerAdded))
		for i, player in ipairs(Players:GetChildren()) do
			onPlayerAdded(player :: Player)
		end
		
		return nil
	end,
	get = function(userId: number, yieldDuration: number?): DataTree?
		local function get()
			return trees[userId]
		end
		local tree = get()
		if not tree and yieldDuration then
			local start = tick()
			repeat
				task.wait()
				tree = get()
			until tree or tick() - start > yieldDuration
			return tree
		else
			return tree
		end
	end,
}