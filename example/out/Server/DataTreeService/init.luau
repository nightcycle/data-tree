--!strict
-- this script was generated by nightcycle/datatree, do not manually edit

--Services
local Players = game:GetService("Players")
local DataStoreService = game:GetService("DataStoreService")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

--Packages
local NetworkUtil = require(script:WaitForChild("Packages"):WaitForChild("NetworkUtil"))
local Maid = require(script:WaitForChild("Packages"):WaitForChild("Maid"))
local Signal = require(script:WaitForChild("Packages"):WaitForChild("Signal"))

--Modules
local DataTypes = require(game:GetService("ReplicatedStorage"):WaitForChild("Shared"):WaitForChild("DataTreeTypes"))

--Types
type Signal = Signal.Signal
type Maid = Maid.Maid
export type VehicleType = DataTypes.VehicleType
export type PermissionData = DataTypes.PermissionData
export type PerformanceData = DataTypes.PerformanceData
export type VehicleData = DataTypes.VehicleData
export type UserId = number
export type UserIdKey = string
type Processor<V> = (val: V) -> V
type Serializer<D,S> = (data: D) -> S
type Deserializer<S,D> = (data: S) -> D
export type DataHandler<T, S> = {
	__index: DataHandler<T, S>,
	_Maid: Maid,
	_IsAlive: boolean,
	_Value: T?,
	_EncodedValue: S?,
	_Serialize: Serializer<T, S>,
	_Deserialize: Deserializer<S, T>,
	OnChanged: Signal,
	ClassName: "DataHandler",
	Key: UserIdKey,
	Player: Player,
	DataStore: DataStore,
	SetOptions: DataStoreSetOptions,
	IncrementOptions: DataStoreIncrementOptions,
	init: (maid: Maid) -> nil,
	new: (player: Player, scope: string, initialValue: T, serializer: Serializer<T,S>?, deserializer: Deserializer<S,T>?) -> DataHandler<T, S>,
	Destroy: (self: DataHandler<T, S>) -> nil,
	Get: (self: DataHandler<T, S>, force: boolean?) -> (T?, boolean),
	Set: (self: DataHandler<T, S>, data: T, force: boolean?) -> boolean,
	Update: (self: DataHandler<T, S>, transformer: (T) -> T, force: boolean?) -> (T?, boolean),
	Remove: (self: DataHandler<T, S>) -> nil,
}
export type SortedDataEntry = {
	UserId: number,
	Value: number,
}
export type NumberDataHandler = DataHandler<number, number> & {
	ClassName: "NumberDataHandler",
	DataStore: OrderedDataStore,
	_EncodedValue: number?,
	_Serialize: Processor<number>,
	_Deserialize: Processor<number>,
	_Value: number?,
	Increment: (self: NumberDataHandler, delta: number, force: boolean?) -> (number?, boolean),
	new: (player: Player, scope: string, initialValue: number, processor: Processor<number>?) -> NumberDataHandler,
	GetSortedList: (self: NumberDataHandler, limit: number, isAscending: boolean) -> { [number]: SortedDataEntry },
}
export type DataTree = {
	CompanyName: DataHandler<string, string>,
	State: DataHandler<Enum.HumanoidStateType, string>,
	Location: DataHandler<CFrame, string>,
	Currency: {
		Cash: NumberDataHandler,
		VehicleCredits: NumberDataHandler,
	},
	Garage: {
		Slots: DataHandler<{[number]: VehicleData}, string>,
		Permissions: DataHandler<{[number]:  PermissionData?}, string>,
	},
}

--Constants
local BASE_DOMAIN = "gamework"
local GET_SUFFIX = "DATA_TREE_CLT_GET"
local UPDATE_SUFFIX = "DATA_TREE_CLT_UPDATE"
local PAGE_LENGTH = 100
local RETRY_LIMIT = if RunService:IsStudio() then 1 else 10
local RETRY_DELAY = if RunService:IsStudio() then 0 else 0.5
local METADATA = {
	["saved_at::DateTime"] = "NOW",
	["major"] = 1,
	["minor"] = 2,
	["patch"] = 3,
}

-- Private functions
function serializeList(unitMethod: (val: any) -> string): (val: { [number]: any }) -> string
	return function(listVal: { [number]: any })
		local out = {}
		for i, v in ipairs(listVal) do
			out[i] = unitMethod(v)
		end
		return HttpService:JSONEncode(out)
	end
end
function deserializeList(unitMethod: (val: string) -> any): (val: string) -> { [number]: any }
	return function(listVal: string)
		local input = HttpService:JSONDecode(listVal)
		local out = {}
		for i, v in ipairs(input) do
			out[i] = unitMethod(v)
		end
		return out
	end
end
function serializeDict(unitMethod: (val: any) -> string): (val: { [string]: any }) -> string
	return function(dictVal: { [string]: any }): string
		local out = {}
		for k, v in pairs(dictVal) do
			out[k] = unitMethod(v)
		end
		return HttpService:JSONEncode(out)
	end
end
function deserializeDict(unitMethod: (val: string) -> any): (val: string) -> { [string]: any }
	return function(dictVal: string): { [string]: any }
		local input = HttpService:JSONDecode(dictVal)
		local out = {}
		for k, v in pairs(input) do
			out[k] = unitMethod(v)
		end
		return out
	end
end

local processors: {[string]: Processor<number>} = {}
processors["Integer"] = function(value: number): number
	return math.round(value)
end
processors["int"] = processors["Integer"]
processors["Double"] = function(value: number): number
	return math.round(value*100)/100
end
processors["double"] = processors["Double"]
processors["Float"] = function(value: number): number
	return value
end
processors["float"] = processors["Float"]



local serializers: {[string]: Serializer<any, any>} = {}
serializers["Color3"] = function(value: Color3): string
	return value:ToHex()
end
serializers["number"] = function(value: number): number
	return value
end
serializers["string"] = function(value: string): string
	return value
end
serializers["boolean"] = function(value: boolean): boolean
	return value
end
serializers["DateTime"] = function(value: DateTime): string
	return value:ToIsoDate()
end
serializers["Vector3"] = function(value: Vector3): string
	return HttpService:JSONEncode({
		X = value.X,
		Y = value.Y,
		Z = value.Z
	})
end
serializers["Vector3Integer"] = function(value: Vector3): string
	return HttpService:JSONEncode({
		X = math.round(value.X),
		Y = math.round(value.Y),
		Z = math.round(value.Z)
	})
end
serializers["Vector3Double"] = function(value: Vector3): string
	return HttpService:JSONEncode({
		X = math.round(value.X*100)/100,
		Y = math.round(value.Y*100)/100,
		Z = math.round(value.Z*100)/100
	})
end
serializers["Vector2"] = function(value: Vector2): string
	return HttpService:JSONEncode({
		X = value.X,
		Y = value.Y
	})
end
serializers["Vector2Integer"] = function(value: Vector2): string
	return HttpService:JSONEncode({
		X = math.round(value.X),
		Y = math.round(value.Y)
	})
end
serializers["Vector2Double"] = function(value: Vector2): string
	return HttpService:JSONEncode({
		X = math.round(value.X*100)/100,
		Y = math.round(value.Y*100)/100
	})
end
serializers["CFrame"] = function(value: CFrame): string
	local x,y,z = value:ToEulerAnglesYXZ()
	return HttpService:JSONEncode({
		Position = serializers["Vector3"](value.Position),
		Orientation = serializers["Vector3"](Vector3.new(math.deg(x), math.deg(y), math.deg(z))),
	})
end
serializers["CFrameDouble"] = function(value: CFrame): string
	local x,y,z = value:ToEulerAnglesYXZ()
	return HttpService:JSONEncode({
		Position = serializers["Vector3Double"](value.Position),
		Orientation = serializers["Vector3Double"](Vector3.new(math.deg(x), math.deg(y), math.deg(z))),
	})
end
serializers["CFrameInteger"] = function(value: CFrame): string
	local x,y,z = value:ToEulerAnglesYXZ()
	return HttpService:JSONEncode({
		Position = serializers["Vector3Integer"](value.Position),
		Orientation = serializers["Vector3Integer"](Vector3.new(math.deg(x), math.deg(y), math.deg(z))),
	})
end
serializers["Enum"] = function(value: EnumItem): number
	return value.Value
end
serializers["PermissionData"] = function(value: PermissionData): string
	return HttpService:JSONEncode({
		["CanDrive"] = serializers["boolean"](value["CanDrive"]),
		["CanEdit"] = serializers["boolean"](value["CanEdit"]),
		["CanSell"] = serializers["boolean"](value["CanSell"]),
	}) :: any
end
serializers["PerformanceData"] = function(value: PerformanceData): string
	return HttpService:JSONEncode({
		["Speed"] = serializers["number"](value["Speed"]),
		["Acceleration"] = serializers["number"](value["Acceleration"]),
		["TurnSpeed"] = serializers["number"](value["TurnSpeed"]),
	}) :: any
end
serializers["VehicleData"] = function(value: VehicleData): string
	return HttpService:JSONEncode({
		["Name"] = serializers["string"](value["Name"]),
		["Type"] = serializers["VehicleType"](value["Type"]),
		["Id"] = serializers["string"](value["Id"]),
		["PurchaseTime"] = serializers["DateTime"](value["PurchaseTime"]),
		["FrictionCoefficient"] = serializers["number"](value["FrictionCoefficient"]),
		["Material"] = serializers["Enum.Material"](value["Material"]),
		["Performance"] = serializers["PerformanceData"](value["Performance"]),
		["Appearance"] = {
			["Color"] = serializers["Color3"](value["Appearance"]["Color"]),
			["Skin"] = serializers["string"](value["Appearance"]["Skin"]),
		},
	}) :: any
end



local deserializers: {[string]: Deserializer<any, any>} = {}
deserializers["string"] = function(value: string): string
	return value
end
deserializers["number"] = function(value: number): number
	return value
end
deserializers["boolean"] = function(value: boolean): boolean
	return value
end
deserializers["Color3"] = function(value: string): Color3
	return Color3.fromHex(value)
end
deserializers["DateTime"] = function(value: string): DateTime
	return DateTime.fromIsoDate(value)
end
deserializers["Vector3"] = function(value: string): Vector3
	local data = HttpService:JSONDecode(value)
	return Vector3.new(data.X, data.Y, data.Z)
end
deserializers["Vector3Integer"] = function(value: string): Vector3
	local data = HttpService:JSONDecode(value)
	return Vector3.new(math.round(data.X), math.round(data.Y), math.round(data.Z))
end
deserializers["Vector3Double"] = function(value: string): Vector3
	local data = HttpService:JSONDecode(value)
	return Vector3.new(math.round(data.X*100)/100, math.round(data.Y*100)/100, math.round(data.Z*100)/100)
end
deserializers["Vector2"] = function(value: string): Vector2
	local data = HttpService:JSONDecode(value)
	return Vector2.new(data.X, data.Y)
end
deserializers["Vector2Integer"] = function(value: string): Vector2
	local data = HttpService:JSONDecode(value)
	return Vector2.new(math.round(data.X), math.round(data.Y))
end
deserializers["Vector2Double"] = function(value: string): Vector2
	local data = HttpService:JSONDecode(value)
	return Vector2.new(math.round(data.X*100)/100, math.round(data.Y*100)/100)
end
deserializers["CFrame"] = function(value: string): CFrame
	local data = HttpService:JSONDecode(value)
	local position = deserializers["Vector3"](data["Position"])
	return CFrame.fromEulerAnglesYXZ(
		math.rad(data.Orientation.X),
		math.rad(data.Orientation.Y),
		math.rad(data.Orientation.Z)
	) + position
end
deserializers["CFrameInteger"] = function(value: string): CFrame
	local data = HttpService:JSONDecode(value)
	local position = deserializers["Vector3Integer"](data["Position"])
	return CFrame.fromEulerAnglesYXZ(
		math.rad(math.round(data.Orientation.X)),
		math.rad(math.round(data.Orientation.Y)),
		math.rad(math.round(data.Orientation.Z))
	) + position
end
deserializers["CFrameDouble"] = function(value: string): CFrame
	local data = HttpService:JSONDecode(value)
	local position = deserializers["Vector3Double"](data["Position"])
	return CFrame.fromEulerAnglesYXZ(
		math.rad(math.round(data.Orientation.X*100)/100),
		math.rad(math.round(data.Orientation.Y*100)/100),
		math.rad(math.round(data.Orientation.Z*100)/100)
	) + position
end
deserializers["Enum.HumanoidStateType"] = function(value: number): Enum.HumanoidStateType
	for i, enumItem in ipairs(Enum.HumanoidStateType:GetEnumItems()) do if enumItem.Value == value then return enumItem end end
error("No enum item found in HumanoidStateType for value "..tostring(value))
end
deserializers["Enum.Material"] = function(value: number): Enum.Material
	for i, enumItem in ipairs(Enum.Material:GetEnumItems()) do if enumItem.Value == value then return enumItem end end
error("No enum item found in Material for value "..tostring(value))
end
deserializers["PermissionData"] = function(value: string): PermissionData
	local data = HttpService:JSONDecode(value)
	return {
		["CanDrive"] = deserializers["boolean"](data["CanDrive"]),
		["CanEdit"] = deserializers["boolean"](data["CanEdit"]),
		["CanSell"] = deserializers["boolean"](data["CanSell"]),
	} :: any
end
deserializers["PerformanceData"] = function(value: string): PerformanceData
	local data = HttpService:JSONDecode(value)
	return {
		["Speed"] = deserializers["number"](data["Speed"]),
		["Acceleration"] = deserializers["number"](data["Acceleration"]),
		["TurnSpeed"] = deserializers["number"](data["TurnSpeed"]),
	} :: any
end
deserializers["VehicleData"] = function(value: string): VehicleData
	local data = HttpService:JSONDecode(value)
	return {
		["Name"] = deserializers["string"](data["Name"]),
		["Type"] = deserializers["VehicleType"](data["Type"]),
		["Id"] = deserializers["string"](data["Id"]),
		["PurchaseTime"] = deserializers["DateTime"](data["PurchaseTime"]),
		["FrictionCoefficient"] = deserializers["number"](data["FrictionCoefficient"]),
		["Material"] = deserializers["Enum.Material"](data["Material"]),
		["Performance"] = deserializers["PerformanceData"](data["Performance"]),
		["Appearance"] = {
			["Color"] = deserializers["Color3"](data["Appearance"]["Color"]),
			["Skin"] = deserializers["string"](data["Appearance"]["Skin"]),
		},
	} :: any
end

--Class
local DataHandler: DataHandler<any, string> = {} :: any
DataHandler.__index = DataHandler

function DataHandler:Destroy()
	if not self._IsAlive then
		return
	end
	
	self._IsAlive = false
	self:Set(self._Value, true)
	self._Maid:Destroy()
	local t: any = self
	for k, v in pairs(t) do
		t[k] = nil
	end
	setmetatable(t, nil)
	return nil
end
function DataHandler:Set(data: any, force: boolean?)
	local initialValue = self._EncodedValue
	local function set()
		local success, errorMessage = pcall(function()
			self.DataStore:SetAsync(self.Key, self._Serialize(data), { self.Player.UserId }, self.SetOptions)
		end)
		if not success then
			warn(errorMessage)
		end
		return success
	end
	local success
	if force then
		local attempts = 0
		repeat
			attempts += 1
			success = set()
			if not success then
				task.wait(RETRY_DELAY)
			end
		until success or attempts > RETRY_LIMIT
	else
		success = true
	end
		if data then
			self._EncodedValue = self._Serialize(data)
		else
			self._EncodedValue = nil
		end
		if self._EncodedValue then
			self._Value = self._Deserialize(self._EncodedValue)
		else
			self._Value = nil
		end
	if initialValue ~= data then
		self.OnChanged:Fire(self._Value)
	end
	return success
end
function DataHandler:Update(transformer: (any) -> any, force: boolean?)
	local initialValue = self._EncodedValue
	local function transformerWrapper(rawValue: any)
		 return self._Serialize(transformer(self._Deserialize(rawValue)))
	end
	local function update()
		local value = self._EncodedValue
		local success, msg = pcall(function()
			value = self.DataStore:UpdateAsync(self.Key, transformerWrapper)
		end)
		if not success then
			warn(msg)
		end
		return value, success
	end
	
	local value, success
	if force then
		local attempts = 0
		repeat
			attempts += 1
			value, success = update()
			if not success then
				task.wait(RETRY_DELAY)
			end
		until success or attempts > RETRY_LIMIT
		if success then
			self._EncodedValue = value
		end
	else
		value = transformerWrapper(initialValue)
		if value then
			self._EncodedValue = value
		else
			self._EncodedValue = nil
		end
	end
		if self._EncodedValue then
			self._Value = self._Deserialize(self._EncodedValue)
		else
			self._Value = nil
		end
	if initialValue ~= value then
		self.OnChanged:Fire(self._Value)
	end
	return self._Value, success
end

function DataHandler:Get(force: boolean?): (any?, boolean)
	if self._Value ~= nil and not force then
		return self._Value, true
	end
	
	local function get()
		local data
		local success, msg = pcall(function()
			data = self.DataStore:GetAsync(self.Key)
		end)
		if not success then
			warn(msg)
		end
		return data, success
	end
	
	local data, success
	local attempts = 0
	repeat
		attempts += 1
		data, success = get()
		if not success then
			task.wait(RETRY_DELAY)
		end
	until success or attempts > RETRY_LIMIT
	
	if success then
		self._EncodedValue = data
		if self._EncodedValue then
			self._Value = self._Deserialize(self._EncodedValue)
		else
			self._Value = nil
		end
	end
	
	return self._Value, success
end

function DataHandler.new(player: Player, scope: string, initialValue: any, serializer: Serializer<any, string>?, deserializer: Deserializer<string, any>?)
	local maid = Maid.new()
	
	local dataStoreOptions = Instance.new("DataStoreOptions")
	maid:GiveTask(dataStoreOptions)
	
	local setOptions = Instance.new("DataStoreSetOptions")
	maid:GiveTask(setOptions)
	setOptions:SetMetadata(METADATA)
	
	local onChanged = Signal.new()
	maid:GiveTask(onChanged)
	
	local self: DataHandler<any, string> = setmetatable({
		_Maid = maid,
		_IsAlive = true,
		_Serialize = if serializer then serializer else function(v: any) return v end,
		_Deserialize = if deserializer then deserializer else function(v: any) return v end,
		OnChanged = onChanged,
		DataStore = if not RunService:IsStudio()
			then DataStoreService:GetDataStore(BASE_DOMAIN, scope, dataStoreOptions)
			else nil :: any,
		_Value = initialValue,
		Key = tostring(player.UserId),
		SetOptions = setOptions,
		Player = player,
	}, DataHandler) :: any
	
	if RunService:IsRunning() then
		local updateEvent = NetworkUtil.getRemoteEvent(scope .. "_" .. UPDATE_SUFFIX, player)
		maid:GiveTask(updateEvent)
		
		maid:GiveTask(onChanged:Connect(function(v: any)
			updateEvent:FireClient(player, v)
		end))
		
		local getFunction = NetworkUtil.getRemoteFunction(scope .. "_" .. GET_SUFFIX, player)
		maid:GiveTask(getFunction)
		getFunction.OnServerInvoke = function(plr: Player)
			if player.UserId == plr.UserId then
				return self._Value
			end
			error("Bad player")
		end
	else
		local updateEvent = NetworkUtil.getBindableEvent(scope .. "_" .. UPDATE_SUFFIX)
		maid:GiveTask(updateEvent)
		
		maid:GiveTask(onChanged:Connect(function(v: any)
			updateEvent:Fire(v)
		end))
		
		local getFunction = NetworkUtil.getBindableFunction(scope .. "_" .. GET_SUFFIX)
		maid:GiveTask(getFunction)
		getFunction.OnInvoke = function()
			return self._Value
		end
	end
	
	self._Value = self:Get(true)
	if self._Value == nil then self._Value = initialValue end
	return self
end

local NumberDataHandler = {}
NumberDataHandler.__index = NumberDataHandler
setmetatable(NumberDataHandler, DataHandler)

-- @TODO
function NumberDataHandler:GetSortedList(player: Player, limit: number, isAscending: boolean)
	local pages = self.Datastore:GetSortedAsync(isAscending, PAGE_LENGTH)
	
	local list: { [number]: SortedDataEntry } = {}
	local function dumpPages()
		local page = pages:GetCurrentPage()
		
		for rank: number, data in ipairs(page) do
			if #list >= limit then
				break
			end
			local key = data.key
			local value = data.value
			table.insert(list, {
				UserId = tonumber(key) :: number,
				Value = value,
			})
		end
		
		local success
		local attempts = 0
		repeat
			success = pcall(function() end)
			attempts += 1
			if not success then
				task.wait(RETRY_DELAY)
			end
		until success or attempts > RETRY_LIMIT
		
		if success and #list < limit then
			pages:AdvanceToNextPageAsync()
			dumpPages()
		end
	end
	dumpPages()
	
	return list
end

function NumberDataHandler:Increment(delta: number, force: boolean?)
	local function increment()
		local value = self._EncodedValue
		local success, msg = pcall(function()
			local val = self.DataStore:IncrementAsync(self.Key, delta, { self.Player.UserId }, self.IncrementOptions)
			value = val
			return val
		end)
		if not success then
			warn(msg)
		end
		return value, success
	end
	
	local value, success
	
	if force then
		local attempts = 0
		repeat
			attempts += 1
			value, success = increment()
			if not success then
				task.wait(RETRY_DELAY)
			end
		until success or attempts > RETRY_LIMIT
		if success then
			self._EncodedValue = value
			self._Value = self.Deserialize(self._EncodedValue)end
	else
		local val: number = self._EncodedValue
		val += delta
		self._EncodedValue = val
		self._Value = self.Deserialize(self._EncodedValue)
		success = true
	end
	
	if success and delta ~= 0 then
		self.OnChanged:Fire(self._Value)
	end
	
	return self._Value, success
end

function NumberDataHandler.new(player: Player, scope: string, initialValue: number, processor: Processor<number>?): NumberDataHandler
	local self: NumberDataHandler = setmetatable(DataHandler.new(player, scope, initialValue, processor :: any, processor :: any), NumberDataHandler) :: any
	
	self.DataStore = if not RunService:IsStudio()
		then DataStoreService:GetOrderedDataStore(BASE_DOMAIN, scope)
		else nil :: any
	
	local incrementOptions = Instance.new("DataStoreIncrementOptions")
	self._Maid:GiveTask(incrementOptions)
	
	incrementOptions:SetMetadata(METADATA)
	self.IncrementOptions = incrementOptions
	
	return self
end
local trees: { [number]: any } = {}

function initPlayer(playerMaid: Maid, player: Player)
	local function _newDataHandler<G, S>(path: string, val: any, serializer: Serializer<G,S>?, deserializer: Deserializer<S, G>?): DataHandler<G, S>
		local handler: DataHandler<G,S> = DataHandler.new(player, path, val, serializer :: any, deserializer :: any) :: any
		playerMaid:GiveTask(handler)
		
		return handler
	end
	
	local function _newNumberHandler(path: string, val: number, processor: Processor<number>?): NumberDataHandler
		local handler: NumberDataHandler = NumberDataHandler.new(player, path, val, processor) :: any
		playerMaid:GiveTask(handler)
		
		return handler
	end
	
	local treeStateVal: Enum.HumanoidStateType = Enum.HumanoidStateType.Dead
	local treeGarageSlotsVal: {[number]:VehicleData} = {
{
	["Name"] = "Lightning McCar",
	["Type"] = "Sedan",
	["Id"] = ""..game:GetService("HttpService"):GenerateGUID(false).."",
	["FrictionCoefficient"] = math.round(100*0.5)/100,
	["Performance"] = {
	["Speed"] = math.round(100*12.0)/100,
	["Acceleration"] = math.round(100*25.0)/100,
	["TurnSpeed"] = math.round(100*5.0)/100,
} :: PerformanceData,
	["Appearance"] = {
		["Color"] = Color3.fromRGB(256, 128, 64),
		["Skin"] = "Lightning",
	},
} :: VehicleData,
}
	local treeGaragePermissionsVal: {[number]: PermissionData?} = {
	[12345] = {
	["CanDrive"] = false,
	["CanEdit"] = true,
	["CanSell"] = true,
} :: PermissionData,
}
	local tree: DataTree = {
			["CompanyName"] = _newDataHandler("CompanyName", ""..player.DisplayName.."'s Company"),
			["State"] = _newDataHandler("State", treeStateVal, serializers["Enum.HumanoidStateType"], deserializers["Enum.HumanoidStateType"]),
			["Location"] = _newDataHandler("Location"),
			["Currency"] = {
				["Cash"] = _newNumberHandler("Currency/Cash", 1000, processors["int"]),
				["VehicleCredits"] = _newNumberHandler("Currency/VehicleCredits", 5, processors["int"]),
			},
			["Garage"] = {
				["Slots"] = _newDataHandler("Garage/Slots", treeGarageSlotsVal, serializeList(serializers["VehicleData"]), deserializeList(deserializers["VehicleData"])) :: any,
				["Permissions"] = _newDataHandler("Garage/Permissions", treeGaragePermissionsVal, serializeDict(serializers[" PermissionData"]), deserializeDict(deserializers[" PermissionData"])) :: any,
			},
		}
	trees[player.UserId] = tree
end

return {
	init = function(maid: Maid): nil
		local function onPlayerAdded(player: Player)
			local playerMaid = Maid.new()
			maid:GiveTask(playerMaid)
			initPlayer(playerMaid, player)
			playerMaid:GiveTask(player.Destroying:Connect(function()
				trees[player.UserId] = nil
				playerMaid:Destroy()
			end))
		end
		
		maid:GiveTask(Players.PlayerAdded:Connect(onPlayerAdded))
		for i, player in ipairs(Players:GetChildren()) do
			onPlayerAdded(player :: Player)
		end
		
		return nil
	end,
	get = function(userId: number, yieldDuration: number?): DataTree?
		local function get()
			return trees[userId]
		end
		local tree = get()
		if not tree and yieldDuration then
			local start = tick()
			repeat
				task.wait()
				tree = get()
			until tree or tick() - start > yieldDuration
			return tree
		else
			return tree
		end
	end,
}